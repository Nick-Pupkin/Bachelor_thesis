---
title: "Spatial dynamic models"
output:
  html_document:
    df_print: paged
---
Links to sources:

https://cran.r-project.org/web/packages/SDPDmod/vignettes/spatial_model.html

https://rdrr.io/github/RozetaSimonovska/SDPDmod/man/SDPDm.html

The folowing research is conducted by Maria R. Koldasheva and Nikolai A. Popov.

## Libraries
```{r Libraries, message=FALSE, warning=FALSE}
library(dplyr) 
library(psych)
library(readxl)
library(writexl)
library(kableExtra)

# Econometrics
library(tidyverse)
library(plm) # panel models
library(sandwich) #covariance matrixes
library(lmtest) # tests
library(xtable)# latex tables
library(stargazer) # latex regression tables
library(ggpubr) # correlation test

# geo
library(sp)
library(spdep)
library(rgdal)
library(maptools)
library(rgeos)
library(sf)
library(spatialreg)
library(modelsummary)
# mass retype()
library(hablar)


# Spartial dynamic models

# install.packages("SDPDmod") # better to do it manually through the R interface

library(SDPDmod)
```

## Downloading the data
```{r Data dowloading}
# Downloading
long_data <- read_csv('C:/Users/Kolya/Documents/New_studies/Diploma/Data/Data_use/Long_united_data.csv',
                      show_col_types = FALSE)

long_data
```

# Dataset for 2015-2019
We exclude 2014 and 2020 as crisis years, to check whether our results are robust.
```{r Dataset for 2015-2019}

long_data <- subset(long_data, year %in% c(2015:2019))
```

## Spatial data, pleliminary cleaning
### Spatial data
```{r Spatial data, message=FALSE, warning=FALSE}
Panel_Ru_shape = readOGR(
  'C:/Users/Kolya/Documents/New_studies/Diploma/Geo/Data_geo/Rus_regions_panel.shp')

Panel_Ru <- Panel_Ru_shape@data

# obtain list of regions (in an appropriate order)
region_order = Panel_Ru$region

# # sorting by 'region'
# Panel_Ru <- Panel_Ru[
#   order(Panel_Ru[,1] ),
# ]
# 
# # reseting index
# rownames(Panel_Ru) <- 1:nrow(Panel_Ru)

```
### Data Transformation
```{r Data Transformation}
# to numeric
Panel_Ru_shape@data[, c(-1)] <-  Panel_Ru_shape@data[, c(-1)] %>% mutate_if(is.character, as.numeric)
# Panel_Ru_shape@data %>% glimpse() #everything is character


### LONG vs.WIDE format
long_spatial_data <- Panel_Ru_shape@data %>% pivot_longer(cols = !region,
                                            names_to = c(".value", "year"),
                                          names_pattern = "([A-Za-z]+)_(\\d+)")

pdim(long_spatial_data) # we have balanced panel
```

## Weight matrix
```{r Weight matrix}
# projection
proj4string(Panel_Ru_shape) <- CRS("+init=epsg:4326")

# listw
map_crd <- coordinates(Panel_Ru_shape)
      Points <- SpatialPoints(map_crd)
      Panel_Ru_shape.knn_8 <- knearneigh(Points, k=8)
      K8_nb <- knn2nb(Panel_Ru_shape.knn_8)
      # Ru_weight_sq <- nb2listw(K8_nb, style="W")
      
# creating binary contiguity matrix

## creating a neighbor matrix
near_neighbor <- apply(matrix(K8_nb),1,unlist) %>% t()

## binary contiguity matrix 
nr <- nrow(near_neighbor)
ru78 <- matrix(0, nr, nr)
for(i in 1:nr) ru78[i, unlist(near_neighbor[i, ])] <- 1

# rename by regions' names
rownames(ru78) = region_order
colnames(ru78) = region_order

# sort by regions' names
ru78 <- ru78[order(rownames(ru78)), order(colnames(ru78))]


# row normalized matrix
W <- rownor(ru78)
isrownor(W)
```


## Model construction


Specifications, Panel models

Theil index specification

Theil <- log(GRP) ~ lag(log(GRP)) + lag(Div) + Edu + Pop + lag(Inv) + lag(FDI) + log(Imp)

EM and IM specification

Margins <- log(GRP) ~ lag(log(GRP)) + lag(EM) + lag(IM) + Edu + Pop + lag(Inv) +lag(FDI)

```{r Specifications, Panel models}
# Theil index specification
Theil_d <- GRP ~ DivL + Edu + Pop + InvL + FDIL + Imp

# EM and IM specification
Margins_d <- GRP ~ EML + IML + Edu + Pop + InvL + FDIL
```


### Manually making logarythms for "SDPDm"
```{r Manually making logarythms for "SDPDm", message=FALSE, warning=FALSE, results='hide'}
# new dataset
long_data_log = data.frame(long_data)

# Check if memory addresses are the same
tracemem(long_data_log) == tracemem(long_data)
# FALSE expected

# logarythm of aprropriate columns
long_data_log$GRP=log(long_data_log$GRP)
long_data_log$Imp=log(long_data_log$Imp)
long_data_log$GRPL = log(long_data_log$GRPL)
```

### Model setting

#### Chosing the correct model specification, Theil

##### Uniform prior check, Theil

```{r Uniform prior, Theil}
Uniform_Theil<-blmpSDPD(formula = Theil_d, W = W,
               data = long_data_log,
               index = c("region","year"),
               model = list("sar","sdm","sem","sdem","slx", "ols"), 
               effect = "twoways",
               ldet = "mc",
               dynamic = TRUE,
               prior = "uniform")
Uniform_Theil$probs
```
We have two available models in SDPDm package: SAR and SDM. As could be observed, SAR model is preferable (has much higher posterior probability). We also don't consider OLS - already built those models.

##### Beta prior check, Theil

```{r Beta prior, Theil}
d_Theil <- plm::pdata.frame(long_data_log, index=c('region', 'year'))
data_Theil<-d_Theil[which(!is.na(d_Theil$GRPL)),]
rownames(data_Theil)<-1:nrow(data_Theil)
kk_Theil<-which(colnames(data_Theil)=="GRPL")

Beta_Theil<- blmpSDPD(formula = Theil_d,
                   W = W,
                   data = data_Theil,
                   index = c("region","year"),
                   model = list("sar","sdm","sem","sdem", "slx", "ols"),
                   effect = "twoways",
                   ldet = "mc",
                   dynamic = TRUE,
                   tlaginfo = list(ind = kk_Theil),
                   prior = "beta")
Beta_Theil$probs
```

SAR is still better than sdm (but now is also is preferred to OLS).



Estimation: Maximum Likelihood

#### Theil
```{r Model setting, Theil}

# Theil
Theil_sp_d <- SDPDm(formula = Theil_d,
            data = long_data_log,
            W = W,
            index = c("region","year"),
            model = "sar", 
            effect = "twoways",
            LYtrans = T,
            dynamic = T,
            tlaginfo = list(ind = NULL, tl = T, stl = T))
            # ind - time lag
            # tl -  lag of the dependent variable in time
            # stl - lag of the dependent variable in space and time
# Theil_sp_d_sum <- summary(Theil_sp_d)
summary(Theil_sp_d)
Theil_sp_d$pval
Theil_imp  <- impactsSDPDm(Theil_sp_d)
Theil_imp
```
Note:

1) LYtrans = T

The Lee-Yu (LY) transformation is a commonly used technique in spatial econometrics to reduce spatial correlation in panel data models. It involves taking the first-differences of each variable in the model and dividing by the square root of the spatial weight matrix. This transformation converts the original spatial panel data model into a non-spatial one, which allows the use of standard panel data estimation techniques. After estimation, the transformed coefficients can be converted back to the original scale by multiplying by the square root of the weight matrix. The LY transformation was introduced by Lee and Yu (2010) as an improvement over earlier transformations that were found to have certain drawbacks.

Note, that p-value in summary is calculated wrongly (for coefficients. It's correct for direct/indirect effects.)
## How to calculate P-value

```{r How to calculate P-value}

# from INDIRECTlt.tab, EML
# Create two vectors of data

R = -0.03427117
SE = 0.23572770
# calculate t-value

t_value <- R / SE

# calculate p-value
p_value <- 2 * pt(abs(t_value), df = Inf, lower.tail = FALSE)
p_value
```
#### Chosing the correct model specification, Margins

##### Uniform prior check, Margins

```{r Uniform prior, Margins}
Uniform_Margins<-blmpSDPD(formula = Margins_d, W = W,
               data = long_data_log,
               index = c("region","year"),
               model = list("sar","sdm","sem","sdem", "slx", "ols"), 
               effect = "twoways",
               ldet = "mc",
               dynamic = TRUE,
               prior = "uniform")
Uniform_Margins$probs
```
We have two available models in SDPDm package: SAR and SDM. As could be observed, SAR model is preferable (has much higher posterior probability). We also don't consider OLS - already built those models.

##### Beta prior check, Margins

```{r Beta prior, Margins}
d_Margins <- plm::pdata.frame(long_data_log, index=c('region', 'year'))
data_Margins<-d_Margins[which(!is.na(d_Margins$GRPL)),]
rownames(data_Margins)<-1:nrow(data_Margins)
Margins_kk<-which(colnames(data_Margins)=="GRPL")

Beta_Margins <- blmpSDPD(formula = Margins_d,
                   W = W,
                   data = data_Margins,
                   index = c("region","year"),
                   model = list("sar","sdm","sem","sdem", "slx", "ols"),
                   effect = "twoways",
                   ldet = "mc",
                   dynamic = TRUE,
                   tlaginfo = list(ind = Margins_kk),
                   prior = "beta")
Beta_Margins$probs
```

SAR is still better than sdm (but now is also is preferred to OLS).

#### Margins
```{r Model setting, Margins}

# Margins
Margins_sp_d <- SDPDm(formula = Margins_d,
            data = long_data_log,
            W = W,
            index = c("region","year"),
            model = "sar", 
            effect = "twoways",
            LYtrans = T,
            dynamic = T,
            tlaginfo = list(ind = NULL, tl = T, stl = T))

# Margins_sp_d_sum <- summary(Margins_sp_d) # R cannot create an object of summary in memory - possible bug
summary(Margins_sp_d)
Margins_imp  <- impactsSDPDm(Margins_sp_d)
Margins_imp
```

# United table creating

```{r DataFrames for tables}
# Table for Theil
united_table_spatial_dynamic_panels_Theil <-
cbind(Theil_sp_d$coefficients1, Theil_sp_d$std1, 2 * pt(abs(Theil_sp_d$coefficients1 / Theil_sp_d$std1), df = Inf, lower.tail = FALSE))

# Table for Margins
united_table_spatial_dynamic_panels_Margins <- 
cbind(Margins_sp_d$coefficients1, Margins_sp_d$std1, 2 * pt(abs(Margins_sp_d$coefficients1 / Margins_sp_d$std1), df = Inf, lower.tail = FALSE))

# matrixes into dataframe
united_table_spatial_dynamic_panels_Theil <- as.data.frame(united_table_spatial_dynamic_panels_Theil)
united_table_spatial_dynamic_panels_Margins <- as.data.frame(united_table_spatial_dynamic_panels_Margins)

# renaming
names(united_table_spatial_dynamic_panels_Theil) <- c('Est_Theil', 'SE_Theil', 'Pvalue_Theil')

names(united_table_spatial_dynamic_panels_Margins) <- c('Est_Margins', 'SE_Margins', 'Pvalue_Margins')

united_table_spatial_dynamic_panels_Theil
united_table_spatial_dynamic_panels_Margins
```

## Table
```{r Table}
library(modelsummary)
ti_Theil <- data.frame(
  term = c('L1.GRP', 'L1.Div', 'L0.Edu', 'L0.Pop', 'L1.Inv', 'L1.FDI', 'L0.Imp'),
  estimate = united_table_spatial_dynamic_panels_Theil$Est_Theil[c(1, 3:8)],
  std.error = united_table_spatial_dynamic_panels_Theil$SE_Theil[c(1, 3:8)],
  p.value = united_table_spatial_dynamic_panels_Theil$Pvalue_Theil[c(1, 3:8)])

ti_Margins <- data.frame(
  term = c('L1.GRP', 'L1.EM', 'L1.IM', 'L0.Edu', 'L0.Pop', 'L1.Inv', 'L1.FDI'),
  estimate = united_table_spatial_dynamic_panels_Margins$Est_Margins[c(1, 3:8)],
  std.error = united_table_spatial_dynamic_panels_Margins$SE_Margins[c(1, 3:8)],
  p.value = united_table_spatial_dynamic_panels_Margins$Pvalue_Margins[c(1, 3:8)])

gl <- data.frame(
  Observations = "546",
  Model = "dynamic SAR")

mod_Theil <- list(tidy = ti_Theil, glance = gl)
mod_Margins <- list(tidy = ti_Margins, glance = gl)

# Model class
class(mod_Theil) <- "modelsummary_list"
class(mod_Margins) <- "modelsummary_list"


# created named list
models <- list()
models[['log(GRP) (1)']] <- mod_Theil
models[['log(GRP) (2)']] <- mod_Margins

# Model
modelsummary(models, stars = T, title = 'Dynamic model', fmt = 4,  coef_map = c('L1.GRP', 'L1.Div',
                                                                               'L1.EM', 'L1.IM',
                                                                               'L0.Edu', 'L0.Pop',
                                                                               'L1.Inv','L1.FDI',
                                                                               'L0.Imp'))

#output = 'latex'
# modelsummary(mod)
```


# SAME CODE, BUT FOR ROBUST DATASET (NO MSK, SPB)


## Downloading the data, robust
```{r Data dowloading, robust}
# Downloading
long_data_robust <- read_csv('C:/Users/Kolya/Documents/New_studies/Diploma/Data/Data_use/Long_united_data_robust.csv',
                      show_col_types = FALSE)

long_data_robust
```

# Dataset for 2015-2019, robust
We exclude 2014 and 2020 as crisis years, to check whether our results are robust.
```{r Dataset for 2015-2019, robust}

long_data_robust <- subset(long_data_robust, year %in% c(2015:2019))
```

## Spatial data, pleliminary cleaning, robust
### Spatial data, robust
```{r Spatial data, robust, message=FALSE, warning=FALSE}
Panel_Ru_shape_robust= readOGR(
  'C:/Users/Kolya/Documents/New_studies/Diploma/Geo/Data_geo/Rus_regions_panel_robust.shp')

Panel_Ru_robust <- Panel_Ru_shape_robust@data

# obtain list of regions (in an appropriate order)
region_order_robust = Panel_Ru_robust$region

# # sorting by 'region'
# Panel_Ru_robust <- Panel_Ru_robust[
#   order(Panel_Ru_robust[,1] ),
# ]
# 
# # reseting index
# rownames(Panel_Ru_robust) <- 1:nrow(Panel_Ru_robust)

```
### Data Transformation, robust
```{r Data Transformation, robust}
# to numeric
Panel_Ru_shape_robust@data[, c(-1)] <-  Panel_Ru_shape_robust@data[, c(-1)] %>% mutate_if(is.character, as.numeric)
# Panel_Ru_shape_robust@data %>% glimpse() #everything is character


### LONG vs.WIDE format
long_spatial_data <- Panel_Ru_shape_robust@data %>% pivot_longer(cols = !region,
                                            names_to = c(".value", "year"),
                                          names_pattern = "([A-Za-z]+)_(\\d+)")

pdim(long_spatial_data) # we have balanced panel
```

## Weight matrix, robust
```{r Weight matrix, robust}
# projection
proj4string(Panel_Ru_shape_robust) <- CRS("+init=epsg:4326")

# listw
map_crd_robust <- coordinates(Panel_Ru_shape_robust)
      Points_robust <- SpatialPoints(map_crd_robust)
      Panel_Ru_shape_robust.knn_8 <- knearneigh(Points_robust, k=8)
      K8_nb_robust <- knn2nb(Panel_Ru_shape_robust.knn_8)
      # Ru_weight_sq <- nb2listw(K8_nb_robust, style="W")
      
# creating binary contiguity matrix

## creating a neighbor matrix
near_neighbor_robust <- apply(matrix(K8_nb_robust),1,unlist) %>% t()

## binary contiguity matrix 
nr_robust <- nrow(near_neighbor_robust)
ru76 <- matrix(0, nr_robust, nr_robust)
for(i in 1:nr_robust) ru76[i, unlist(near_neighbor_robust[i, ])] <- 1

# rename by regions' names
rownames(ru76) = region_order_robust
colnames(ru76) = region_order_robust

# sort by regions' names
ru76 <- ru76[order(rownames(ru76)), order(colnames(ru76))]


# row normalized matrix
W_robust <- rownor(ru76)
isrownor(W_robust)
```


## Model construction, robust


Specifications, Panel models

Theil_robust index specification

Theil_robust <- log(GRP) ~ lag(log(GRP)) + lag(Div) + Edu + Pop + lag(Inv) + lag(FDI) + log(Imp)

EM and IM specification

Margins_robust <- log(GRP) ~ lag(log(GRP)) + lag(EM) + lag(IM) + Edu + Pop + lag(Inv) +lag(FDI)

```{r Specifications, Panel models, robust}
# Theil_robust index specification
Theil_robust_d <- GRP ~ DivL + Edu + Pop + InvL + FDIL + Imp

# EM and IM specification
Margins_robust_d <- GRP ~ EML + IML + Edu + Pop + InvL + FDIL
```


### Manually making logarythms for "SDPDm", robust
```{r Manually making logarythms for "SDPDm", robust, message=FALSE, warning=FALSE, results='hide'}
# new dataset
long_data_robust_log = data.frame(long_data_robust)

# Check if memory addresses are the same
tracemem(long_data_robust_log) == tracemem(long_data_robust)
# FALSE expected

# logarythm of aprropriate columns
long_data_robust_log$GRP=log(long_data_robust_log$GRP)
long_data_robust_log$Imp=log(long_data_robust_log$Imp)
long_data_robust_log$GRPL = log(long_data_robust_log$GRPL)
```

### Model setting, robust

#### Chosing the correct model specification, Theil_robust

##### Uniform prior check, Theil_robust

```{r Uniform prior, Theil_robust}
Uniform_Theil_robust<-blmpSDPD(formula = Theil_robust_d, W = W_robust,
               data = long_data_robust_log,
               index = c("region","year"),
               model = list("sar","sdm","sem","sdem","slx", "ols"), 
               effect = "twoways",
               ldet = "mc",
               dynamic = TRUE,
               prior = "uniform")
Uniform_Theil_robust$probs
```
We have two available models in SDPDm package: SAR and SDM. As could be observed, SAR model is preferable (has much higher posterior probability). We also don't consider OLS - already built those models.

##### Beta prior check, Theil_robust

```{r Beta prior, Theil_robust}
d_Theil_robust <- plm::pdata.frame(long_data_robust_log, index=c('region', 'year'))
data_Theil_robust<-d_Theil_robust[which(!is.na(d_Theil_robust$GRPL)),]
rownames(data_Theil_robust)<-1:nrow(data_Theil_robust)
kk_Theil_robust<-which(colnames(data_Theil_robust)=="GRPL")

Beta_Theil_robust<- blmpSDPD(formula = Theil_robust_d,
                   W = W_robust,
                   data = data_Theil_robust,
                   index = c("region","year"),
                   model = list("sar","sdm","sem","sdem", "slx", "ols"),
                   effect = "twoways",
                   ldet = "mc",
                   dynamic = TRUE,
                   tlaginfo = list(ind = kk_Theil_robust),
                   prior = "beta")
Beta_Theil_robust$probs
```

SAR is still better than sdm (but now is also is preferred to OLS).



Estimation: Maximum Likelihood

#### Theil_robust, robust
```{r Model setting, Theil_robust}

# Theil_robust
Theil_robust_sp_d <- SDPDm(formula = Theil_robust_d,
            data = long_data_robust_log,
            W = W_robust,
            index = c("region","year"),
            model = "sar", 
            effect = "twoways",
            LYtrans = T,
            dynamic = T,
            tlaginfo = list(ind = NULL, tl = T, stl = T))
            # ind - time lag
            # tl -  lag of the dependent variable in time
            # stl - lag of the dependent variable in space and time
# Theil_robust_sp_d_sum <- summary(Theil_robust_sp_d)
summary(Theil_robust_sp_d)

Theil_robust_imp  <- impactsSDPDm(Theil_robust_sp_d)
Theil_robust_imp
```
Note:

1) LYtrans = T

The Lee-Yu (LY) transformation is a commonly used technique in spatial econometrics to reduce spatial correlation in panel data models. It involves taking the first-differences of each variable in the model and dividing by the square root of the spatial weight matrix. This transformation converts the original spatial panel data model into a non-spatial one, which allows the use of standard panel data estimation techniques. After estimation, the transformed coefficients can be converted back to the original scale by multiplying by the square root of the weight matrix. The LY transformation was introduced by Lee and Yu (2010) as an improvement over earlier transformations that were found to have certain drawbacks.

#### Chosing the correct model specification, Margins_robust

##### Uniform prior check, Margins_robust

```{r Uniform prior, Margins_robust}
Uniform_Margins_robust<-blmpSDPD(formula = Margins_robust_d, W = W_robust,
               data = long_data_robust_log,
               index = c("region","year"),
               model = list("sar","sdm","sem","sdem", "slx", "ols"), 
               effect = "twoways",
               ldet = "mc",
               dynamic = TRUE,
               prior = "uniform")
Uniform_Margins_robust$probs
```
We have two available models in SDPDm package: SAR and SDM. As could be observed, SAR model is preferable (has much higher posterior probability). We also don't consider OLS - already built those models.

##### Beta prior check, Margins_robust

```{r Beta prior, Margins_robust}
d_Margins_robust <- plm::pdata.frame(long_data_robust_log, index=c('region', 'year'))
data_Margins_robust<-d_Margins_robust[which(!is.na(d_Margins_robust$GRPL)),]
rownames(data_Margins_robust)<-1:nrow(data_Margins_robust)
Margins_robust_kk<-which(colnames(data_Margins_robust)=="GRPL")

Beta_Margins_robust <- blmpSDPD(formula = Margins_robust_d,
                   W = W_robust,
                   data = data_Margins_robust,
                   index = c("region","year"),
                   model = list("sar","sdm","sem","sdem", "slx", "ols"),
                   effect = "twoways",
                   ldet = "mc",
                   dynamic = TRUE,
                   tlaginfo = list(ind = Margins_robust_kk),
                   prior = "beta")
Beta_Margins_robust$probs
```

SAR is still better than sdm.

#### Margins_robust
```{r Model setting, Margins_robust}

# Margins_robust
Margins_robust_sp_d <- SDPDm(formula = Margins_robust_d,
            data = long_data_robust_log,
            W = W_robust,
            index = c("region","year"),
            model = "sar", 
            effect = "twoways",
            LYtrans = T,
            dynamic = T,
            tlaginfo = list(ind = NULL, tl = T, stl = T))

# Margins_robust_sp_d_sum <- summary(Margins_robust_sp_d) # R cannot create an object of summary in memory - possible bug
summary(Margins_robust_sp_d)
Margins_robust_imp  <- impactsSDPDm(Margins_robust_sp_d)
Margins_robust_imp
```

# United table creating, robust

```{r DataFrames for tables, robust}
# Table for Theil_robust
united_table_spatial_dynamic_panels_Theil_robust <-
cbind(Theil_robust_sp_d$coefficients1, Theil_robust_sp_d$std1, 2 * pt(abs(Theil_robust_sp_d$coefficients1 / Theil_robust_sp_d$std1), df = Inf, lower.tail = FALSE))

# Table for Margins_robust
united_table_spatial_dynamic_panels_Margins_robust <- 
cbind(Margins_robust_sp_d$coefficients1, Margins_robust_sp_d$std1, 2 * pt(abs(Margins_robust_sp_d$coefficients1 / Margins_robust_sp_d$std1), df = Inf, lower.tail = FALSE))

# matrixes into dataframe
united_table_spatial_dynamic_panels_Theil_robust <- as.data.frame(united_table_spatial_dynamic_panels_Theil_robust)
united_table_spatial_dynamic_panels_Margins_robust <- as.data.frame(united_table_spatial_dynamic_panels_Margins_robust)

# renaming
names(united_table_spatial_dynamic_panels_Theil_robust) <- c('Est_Theil_robust', 'SE_Theil_robust', 'Pvalue_Theil_robust')

names(united_table_spatial_dynamic_panels_Margins_robust) <- c('Est_Margins_robust', 'SE_Margins_robust', 'Pvalue_Margins_robust')

united_table_spatial_dynamic_panels_Theil_robust
united_table_spatial_dynamic_panels_Margins_robust
```

## Table, robust
```{r Table, robust}
library(modelsummary)
ti_Theil_robust <- data.frame(
  term = c('L1.GRP', 'L1.Div', 'L0.Edu', 'L0.Pop', 'L1.Inv', 'L1.FDI', 'L0.Imp'),
  estimate = united_table_spatial_dynamic_panels_Theil_robust$Est_Theil_robust[c(1, 3:8)],
  std.error = united_table_spatial_dynamic_panels_Theil_robust$SE_Theil_robust[c(1, 3:8)],
  p.value = united_table_spatial_dynamic_panels_Theil_robust$Pvalue_Theil_robust[c(1, 3:8)])

ti_Margins_robust <- data.frame(
  term = c('L1.GRP', 'L1.EM', 'L1.IM', 'L0.Edu', 'L0.Pop', 'L1.Inv', 'L1.FDI'),
  estimate = united_table_spatial_dynamic_panels_Margins_robust$Est_Margins_robust[c(1, 3:8)],
  std.error = united_table_spatial_dynamic_panels_Margins_robust$SE_Margins_robust[c(1, 3:8)],
  p.value = united_table_spatial_dynamic_panels_Margins_robust$Pvalue_Margins_robust[c(1, 3:8)])

gl <- data.frame(
  Observations = "532",
  Model = "dynamic SAR")

mod_Theil_robust <- list(tidy = ti_Theil_robust, glance = gl)
mod_Margins_robust <- list(tidy = ti_Margins_robust, glance = gl)

# Model class
class(mod_Theil_robust) <- "modelsummary_list"
class(mod_Margins_robust) <- "modelsummary_list"


# created named list
models <- list()
models[['log(GRP) (1)']] <- mod_Theil_robust
models[['log(GRP) (2)']] <- mod_Margins_robust

# Model
modelsummary(models, stars = T, title = 'Dynamic model', fmt = 4,  coef_map = c('L1.GRP', 'L1.Div',
                                                                               'L1.EM', 'L1.IM',
                                                                               'L0.Edu', 'L0.Pop',
                                                                               'L1.Inv','L1.FDI',
                                                                               'L0.Imp'))

#output = 'latex'
# modelsummary(mod)
```



# Final table

```{r Final table}
# created named list
models <- list()
models[['log(GRP) (1)']] <- mod_Theil
models[['log(GRP) (2)']] <- mod_Theil_robust
models[['log(GRP) (3)']] <- mod_Margins
models[['log(GRP) (4)']] <- mod_Margins_robust
# Model
modelsummary(models, stars = T, title = 'Dynamic model, robust (no crisis years)',
             fmt = 4, coef_map =c('L1.GRP', 'L1.Div','L1.EM', 'L1.IM','L0.Edu',
                                  'L0.Pop','L1.Inv','L1.FDI','L0.Imp'))
```

